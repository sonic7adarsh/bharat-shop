package com.bharatshop.shared.mapper;

import com.bharatshop.shared.dto.ProductVariantDto;
import com.bharatshop.shared.entity.ProductVariant;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.springframework.beans.factory.annotation.Autowired;

import java.math.BigDecimal;
import java.util.List;
import java.util.Map;

/**
 * MapStruct mapper for ProductVariant entity and DTOs.
 * Provides type-safe mapping between domain objects and DTOs.
 */
@Mapper(
    componentModel = "spring",
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE,
    uses = {ProductVariantOptionValueMapper.class}
)
public abstract class ProductVariantMapper {
    
    @Autowired
    protected ObjectMapper objectMapper;
    
    /**
     * Maps ProductVariant entity to ProductVariantDto.
     */
    @Mapping(target = "attributes", source = "attributes", qualifiedByName = "jsonToMap")
    @Mapping(target = "product", ignore = true) // Mapped separately to avoid circular references
    @Mapping(target = "optionValues", ignore = true) // Mapped separately
    @Mapping(target = "imageUrl", ignore = true) // Computed field
    @Mapping(target = "effectivePrice", ignore = true) // Computed field
    @Mapping(target = "isOnSale", ignore = true) // Computed field
    @Mapping(target = "discountAmount", ignore = true) // Computed field
    @Mapping(target = "discountPercentage", ignore = true) // Computed field
    @Mapping(target = "isInStock", ignore = true) // Computed field
    @Mapping(target = "isLowStock", ignore = true) // Computed field
    @Mapping(target = "variantTitle", ignore = true) // Computed field
    @Mapping(target = "optionValueNames", ignore = true) // Computed field
    public abstract ProductVariantDto toDto(ProductVariant productVariant);
    
    /**
     * Maps ProductVariantDto to ProductVariant entity.
     */
    @Mapping(target = "id", ignore = true) // Generated by database
    @Mapping(target = "tenantId", ignore = true) // Set by service
    @Mapping(target = "createdAt", ignore = true) // Set by auditing
    @Mapping(target = "updatedAt", ignore = true) // Set by auditing
    @Mapping(target = "deletedAt", ignore = true) // Set by soft delete
    @Mapping(target = "attributes", source = "attributes", qualifiedByName = "mapToJson")
    @Mapping(target = "product", ignore = true) // Handled separately
    @Mapping(target = "productVariantOptionValues", ignore = true) // Handled separately
    @Mapping(target = "productImage", ignore = true) // Handled separately
    public abstract ProductVariant toEntity(ProductVariantDto productVariantDto);
    
    /**
     * Updates existing ProductVariant entity with ProductVariantDto data.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "productId", ignore = true) // Should not be changed after creation
    @Mapping(target = "tenantId", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    @Mapping(target = "attributes", source = "attributes", qualifiedByName = "mapToJson")
    @Mapping(target = "product", ignore = true)
    @Mapping(target = "productVariantOptionValues", ignore = true)
    @Mapping(target = "productImage", ignore = true)
    public abstract void updateEntity(ProductVariantDto productVariantDto, @MappingTarget ProductVariant productVariant);
    
    /**
     * Maps list of ProductVariant entities to list of ProductVariantDtos.
     */
    public abstract List<ProductVariantDto> toDtoList(List<ProductVariant> productVariants);
    
    /**
     * Maps list of ProductVariantDtos to list of ProductVariant entities.
     */
    public abstract List<ProductVariant> toEntityList(List<ProductVariantDto> productVariantDtos);
    
    /**
     * Maps ProductVariantDto with computed fields for display.
     */
    public ProductVariantDto toDtoWithComputedFields(ProductVariant productVariant) {
        ProductVariantDto dto = toDto(productVariant);
        
        // Set computed fields
        dto.setEffectivePrice(calculateEffectivePrice(dto.getPrice(), dto.getSalePrice()));
        dto.setIsOnSale(isOnSale(dto.getPrice(), dto.getSalePrice()));
        dto.setDiscountAmount(calculateDiscountAmount(dto.getPrice(), dto.getSalePrice()));
        dto.setDiscountPercentage(calculateDiscountPercentage(dto.getPrice(), dto.getSalePrice()));
        dto.setIsInStock(dto.getStock() != null && dto.getStock() > 0);
        dto.setIsLowStock(dto.getStock() != null && dto.getStock() > 0 && dto.getStock() <= 5); // Default threshold
        
        return dto;
    }
    
    /**
     * Converts JSON string to Map.
     */
    @Named("jsonToMap")
    protected Map<String, Object> jsonToMap(String json) {
        if (json == null || json.trim().isEmpty()) {
            return null;
        }
        try {
            return objectMapper.readValue(json, new TypeReference<Map<String, Object>>() {});
        } catch (JsonProcessingException e) {
            return null;
        }
    }
    
    /**
     * Converts Map to JSON string.
     */
    @Named("mapToJson")
    protected String mapToJson(Map<String, Object> map) {
        if (map == null || map.isEmpty()) {
            return null;
        }
        try {
            return objectMapper.writeValueAsString(map);
        } catch (JsonProcessingException e) {
            return null;
        }
    }
    
    // Helper methods for computed fields
    private BigDecimal calculateEffectivePrice(BigDecimal price, BigDecimal salePrice) {
        if (salePrice != null && salePrice.compareTo(BigDecimal.ZERO) > 0 && salePrice.compareTo(price) < 0) {
            return salePrice;
        }
        return price;
    }
    
    private Boolean isOnSale(BigDecimal price, BigDecimal salePrice) {
        return salePrice != null && salePrice.compareTo(BigDecimal.ZERO) > 0 && salePrice.compareTo(price) < 0;
    }
    
    private BigDecimal calculateDiscountAmount(BigDecimal price, BigDecimal salePrice) {
        if (isOnSale(price, salePrice)) {
            return price.subtract(salePrice);
        }
        return BigDecimal.ZERO;
    }
    
    private Double calculateDiscountPercentage(BigDecimal price, BigDecimal salePrice) {
        if (isOnSale(price, salePrice) && price.compareTo(BigDecimal.ZERO) > 0) {
            BigDecimal discount = price.subtract(salePrice);
            return discount.divide(price, 4, BigDecimal.ROUND_HALF_UP).multiply(BigDecimal.valueOf(100)).doubleValue();
        }
        return 0.0;
    }
}